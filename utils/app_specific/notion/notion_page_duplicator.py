#!/usr/bin/env python3
"""
Notion Page Duplicator
======================

A standalone script to duplicate a specific child page from one parent page 
to another parent page using Playwright automation and Notion API.

Usage:
    python notion_page_duplicator.py \
        --source-parent "https://notion.so/your-source-page-url" \
        --child-name "Child Page Name" \
        --target-parent "https://notion.so/your-target-page-url" \
        --notion-key "your_notion_api_key" \
        --output-file "./duplicated_page_id.txt"

Requirements:
    - notion_state.json file (generated by notion login helper)
    - Playwright installed with browser
    - notion-client package
"""

import argparse
import re
import time
from pathlib import Path
from typing import Optional, Tuple

from notion_client import Client
from playwright.sync_api import Browser, Page, sync_playwright, TimeoutError as PlaywrightTimeoutError

# Import the protection module
import sys
import os
sys.path.append(os.path.dirname(os.path.abspath(__file__)))
from notion_page_protector import NotionPageProtector

# Selectors for Notion UI elements (same as in the original code)
PAGE_MENU_BUTTON_SELECTOR = '[data-testid="more-button"], div.notion-topbar-more-button, [aria-label="More"], button[aria-label="More"]'
DUPLICATE_MENU_ITEM_SELECTOR = 'text="Duplicate"'
MOVE_TO_MENU_ITEM_SELECTOR = 'text="Move to"'
MOVE_TO_SEARCH_INPUT_SELECTOR = 'input[placeholder*="Move page to"], textarea[placeholder*="Move page to"]'

class NotionPageDuplicator:
    """Standalone Notion page duplicator using Playwright and Notion API."""
    
    def __init__(self, notion_key: str, browser: str = "firefox", headless: bool = True, state_path: str = "./configs/notion_state.json"):
        """
        Initialize the duplicator.

        Args:
            notion_key: Notion API integration token
            browser: Browser to use ("firefox" or "chromium")
            headless: Whether to run browser in headless mode
        """
        self.notion_client = Client(auth=notion_key)
        self.browser_name = browser
        self.headless = headless
        self.state_file = Path(state_path)
        self.duplicated_page_id = None  # Store the duplicated page ID

        # Initialize the protector
        self.protector = NotionPageProtector()

        if not self.state_file.exists():
            raise FileNotFoundError(
                f"Authentication state file '{self.state_file}' not found. "
                "Please run the notion login helper first."
            )
    
    def extract_page_id_from_url(self, url: str) -> str:
        """Extract page ID from a Notion URL."""
        # Remove query parameters and fragments
        slug = url.split("?")[0].split("#")[0].rstrip("/").split("/")[-1]
        
        # Extract alphanumeric characters
        compact = "".join(c for c in slug if c.isalnum())
        
        if len(compact) < 32:
            raise ValueError(f"Could not parse page ID from URL: {url}")
        
        # Take last 32 characters and format as UUID
        compact = compact[-32:]
        return f"{compact[:8]}-{compact[8:12]}-{compact[12:16]}-{compact[16:20]}-{compact[20:]}"
    
    def find_child_page_by_name(self, parent_page_id: str, child_name: str) -> Optional[Tuple[str, str]]:
        """
        Find a child page by name under the given parent page.
        
        Returns:
            Tuple of (child_page_id, child_page_url) if found, None otherwise
        """
        try:
            # Get all child blocks of the parent page
            children = self.notion_client.blocks.children.list(block_id=parent_page_id)
            
            for child in children.get("results", []):
                if child.get("type") == "child_page":
                    # Get the child page details to check its title
                    child_page = self.notion_client.pages.retrieve(page_id=child["id"])
                    
                    # Extract title from page properties
                    props = child_page.get("properties", {})
                    title_prop = props.get("title", {}).get("title") or props.get("Name", {}).get("title")
                    
                    if title_prop:
                        title = "".join(t.get("plain_text", "") for t in title_prop).strip()
                        if title == child_name:
                            return child["id"], child_page.get("url", "")
            
            return None
            
        except Exception as e:
            print(f"Error finding child page '{child_name}': {e}")
            return None
    
    def get_page_title_by_id(self, page_id: str) -> str:
        """Get the title of a page by its ID."""
        try:
            page = self.notion_client.pages.retrieve(page_id=page_id)
            props = page.get("properties", {})
            title_prop = props.get("title", {}).get("title") or props.get("Name", {}).get("title")
            
            if title_prop:
                return "".join(t.get("plain_text", "") for t in title_prop).strip()
            return "Untitled"
            
        except Exception as e:
            print(f"Error getting page title for {page_id}: {e}")
            return "Unknown"
    
    def rename_page_via_api(self, page_id: str, new_title: str) -> bool:
        """Rename a Notion page using the API."""
        try:
            # First, get the current title for validation
            try:
                page = self.notion_client.pages.retrieve(page_id=page_id)
                props = page.get("properties", {})
                title_prop = props.get("title", {}).get("title") or props.get("Name", {}).get("title")
                current_title = "".join(t.get("plain_text", "") for t in title_prop).strip() if title_prop else "Untitled"
            except:
                current_title = "Unknown"

            # Validate the rename operation with protector
            is_valid, error_msg = self.protector.validate_rename_operation(page_id, current_title, new_title)
            if not is_valid:
                print(f"ERROR: {error_msg}")
                raise Exception(error_msg)

            # Proceed with rename
            self.notion_client.pages.update(
                page_id=page_id,
                properties={"title": {"title": [{"text": {"content": new_title}}]}},
            )
            print(f"Page renamed to: {new_title}")
            return True
        except Exception as e:
            print(f"Failed to rename page via API: {e}")
            return False

    def clear_modal_overlay(self, page: Page, timeout: int = 10_000) -> bool:
        """尝试清除modal overlay的综合策略"""
        modal_selector = "div.notion-modal-underlay"

        # 策略1: 等待10秒看是否自动消失
        try:
            page.wait_for_selector(modal_selector, state="detached", timeout=timeout)
            print("✅ Modal overlay cleared automatically")
            return True
        except:
            print("⚠️ Modal overlay still present after 10s")

        # 策略2: 按ESC键尝试关闭
        try:
            page.keyboard.press("Escape")
            time.sleep(1)
            page.wait_for_selector(modal_selector, state="detached", timeout=2_000)
            print("✅ Modal cleared by ESC key")
            return True
        except:
            print("❌ ESC key didn't work")

        # 策略3: 点击modal外部区域
        try:
            # 点击页面左上角空白区域
            page.click("body", position={"x": 50, "y": 50}, timeout=2_000)
            time.sleep(1)
            page.wait_for_selector(modal_selector, state="detached", timeout=2_000)
            print("✅ Modal cleared by clicking outside")
            return True
        except:
            print("❌ Clicking outside didn't work")

        # 策略4: 刷新页面（最后手段）
        try:
            print("🔄 Refreshing page as last resort...")
            current_url = page.url
            page.goto(current_url, wait_until="load", timeout=30_000)
            time.sleep(3)
            print("✅ Page refreshed successfully")
            return True
        except:
            print("❌ Page refresh failed")
            return False

    def duplicate_page_with_playwright(self, parent_of_source_page_url: str, source_page_url: str, target_parent_title: str, original_child_name: str) -> Optional[str]:
        """
        Duplicate a page using Playwright automation and move it to target parent.
        
        Args:
            source_page_url: URL of the page to duplicate
            target_parent_title: Title of the target parent page
            original_child_name: Original name of the child page (for renaming)
            
        Returns:
            URL of the duplicated page if successful, None otherwise
        """
        try:
            with sync_playwright() as p:
                browser_type = getattr(p, self.browser_name)
                browser: Browser = browser_type.launch(headless=self.headless)
                context = browser.new_context(storage_state=str(self.state_file))
                page = context.new_page()

                # Validate we're not duplicating FROM a protected page
                is_valid, error_msg = self.protector.validate_url_operation(source_page_url, "duplicate from")
                if not is_valid:
                    # It's OK to duplicate FROM a child of a protected page, just warn
                    print(f"WARNING: Duplicating from what might be related to a protected page: {source_page_url}")

                print(f"Navigating to source page: {source_page_url}")
                initial_url = page.url if hasattr(page, 'url') else None
                page.goto(source_page_url, wait_until="load", timeout=60_000)
                
                # Wait for navigation to complete and verify we actually navigated
                time.sleep(3)
                page.wait_for_load_state("load", timeout=15_000)

                # Verify we navigated to the correct page
                current_url = page.url
                print(f"Current URL after navigation: {current_url}")

                # Extract the page ID from where we wanted to go
                target_page_id = self.extract_page_id_from_url(source_page_url)
                # Extract the page ID from where we actually are
                current_page_id = self.extract_page_id_from_url(current_url)

                # Check if we're on the right page
                if current_page_id != target_page_id:
                    print(f"WARNING: Navigation verification failed!")
                    print(f"Expected to be on page: {target_page_id}")
                    print(f"Actually on page: {current_page_id}")

                    # Try one more time with a direct navigation
                    print("Retrying navigation...")
                    page.goto(source_page_url, wait_until="load", timeout=60_000)
                    time.sleep(5)

                    current_url = page.url
                    current_page_id = self.extract_page_id_from_url(current_url)

                    if current_page_id != target_page_id:
                        raise Exception(f"Failed to navigate to target page. Expected: {target_page_id}, Current: {current_page_id}")

                print(f"Successfully verified navigation to target page: {current_page_id}")

                # Save updated auth state
                context.storage_state(path=str(self.state_file))

                # Step 1: Duplicate the page
                print("Opening page menu...")
                page.wait_for_selector(PAGE_MENU_BUTTON_SELECTOR, state="visible", timeout=30_000)
                page.click(PAGE_MENU_BUTTON_SELECTOR)
                
                print("Clicking 'Duplicate'...")
                page.hover(DUPLICATE_MENU_ITEM_SELECTOR)
                page.click(DUPLICATE_MENU_ITEM_SELECTOR)
                
                # Wait for duplication to complete (URL will change)
                original_url = page.url
                original_page_id = self.extract_page_id_from_url(original_url)
                source_parent_id = self.extract_page_id_from_url(parent_of_source_page_url)
                print(f"Original page ID before duplication: {original_page_id}")
                print(f"Source parent ID: {source_parent_id}")
                print("Waiting for duplication to complete...")

                # Wait for URL to change from the original page
                page.wait_for_url(lambda url: url != original_url, timeout=180_000)

                # Keep checking until we get to a page that is neither the original nor the source parent
                max_attempts = 10
                attempt = 0
                duplicated_page_id = None

                while attempt < max_attempts:
                    attempt += 1
                    time.sleep(2)  # Give Notion time to process

                    current_url = page.url
                    print(f"Attempt {attempt}: Current URL: {current_url}")

                    # Try to extract page ID from current URL
                    current_page_id = self.extract_page_id_from_url(current_url)

                    # Also check if there's a page ID in the URL fragment
                    fragment_page_id = None
                    if '#' in current_url:
                        fragment = current_url.split('#')[-1]
                        # Remove any query parameters from fragment
                        fragment = fragment.split('?')[0].split('&')[0]
                        # Extract alphanumeric characters from fragment
                        compact = "".join(c for c in fragment if c.isalnum())
                        if len(compact) >= 32:
                            # Take last 32 characters and format as UUID
                            compact = compact[-32:]
                            fragment_page_id = f"{compact[:8]}-{compact[8:12]}-{compact[12:16]}-{compact[16:20]}-{compact[20:]}"
                            print(f"Found page ID in fragment: {fragment_page_id}")

                    # Check if we have a valid new page ID
                    candidate_page_id = None
                    if current_page_id != original_page_id and current_page_id != source_parent_id:
                        candidate_page_id = current_page_id
                        print(f"Found new page ID in main URL: {candidate_page_id}")
                    elif fragment_page_id and fragment_page_id != original_page_id and fragment_page_id != source_parent_id:
                        candidate_page_id = fragment_page_id
                        print(f"Found new page ID in fragment: {candidate_page_id}")

                    if candidate_page_id:
                        # Verify this page actually exists by calling the API
                        try:
                            page_info = self.notion_client.pages.retrieve(page_id=candidate_page_id)
                            if page_info:
                                duplicated_page_id = candidate_page_id
                                print(f"✅ Confirmed duplicated page ID: {duplicated_page_id}")
                                break
                        except Exception as e:
                            print(f"Page ID {candidate_page_id} verification failed: {e}")

                    print(f"Still waiting for valid duplicate page... (current: {current_page_id}, fragment: {fragment_page_id})")

                if not duplicated_page_id:
                    raise Exception(f"Failed to find valid duplicated page after {max_attempts} attempts")

                duplicated_url = page.url
                print(f"Page duplicated successfully: {duplicated_url}")

                self.duplicated_page_id = duplicated_page_id
                print(f"Duplicated page ID: {duplicated_page_id}")

                # Validate that we're not moving a protected page
                is_valid, error_msg = self.protector.validate_move_operation(
                    duplicated_page_id,
                    original_page_id,  # source parent (where it was duplicated)
                )
                if not is_valid:
                    print(f"ERROR: {error_msg}")
                    raise Exception(error_msg)

                # CRITICAL: Before moving, ensure we're on the duplicated page
                duplicated_page_url = f"https://www.notion.so/{duplicated_page_id.replace('-', '')}"
                current_url = page.url
                current_page_id = self.extract_page_id_from_url(current_url)

                if current_page_id != duplicated_page_id:
                    print(f"⚠️ Not on duplicated page (current: {current_page_id}, expected: {duplicated_page_id})")
                    print(f"Navigating to duplicated page: {duplicated_page_url}")

                    # Navigate to the duplicated page
                    page.goto(duplicated_page_url, wait_until="load", timeout=60_000)
                    time.sleep(3)
                    page.wait_for_load_state("load", timeout=15_000)

                    # Verify we're now on the correct page
                    current_url = page.url
                    current_page_id = self.extract_page_id_from_url(current_url)

                    if current_page_id != duplicated_page_id:
                        raise Exception(f"Failed to navigate to duplicated page. Expected: {duplicated_page_id}, Current: {current_page_id}")

                    print(f"✅ Successfully navigated to duplicated page: {duplicated_page_id}")
                else:
                    print(f"✅ Already on duplicated page: {duplicated_page_id}")

                # Step 2: Move the duplicated page to target parent
                print(f"Moving duplicated page to target parent: {target_parent_title}")

                # 清理modal状态
                if not self.clear_modal_overlay(page):
                    raise Exception("Failed to clear modal overlay after all attempts")

                # Open page menu again
                page.wait_for_selector(PAGE_MENU_BUTTON_SELECTOR, state="visible", timeout=30_000)
                page.click(PAGE_MENU_BUTTON_SELECTOR)
                
                # Click "Move to"
                page.hover(MOVE_TO_MENU_ITEM_SELECTOR)
                page.click(MOVE_TO_MENU_ITEM_SELECTOR)
                
                # Fill in target parent title
                page.wait_for_selector(MOVE_TO_SEARCH_INPUT_SELECTOR, state="visible", timeout=15_000)
                search_input = page.locator(MOVE_TO_SEARCH_INPUT_SELECTOR).first
                search_input.click()
                search_input.fill("")  # Clear any existing text
                search_input.type(target_parent_title, delay=50)
                
                # Wait for search result and click it
                result_selector = f'div[role="menuitem"]:has-text("{target_parent_title}")'
                page.wait_for_selector(result_selector, state="visible", timeout=60_000)
                page.locator(result_selector).first.click(force=True)
                
                # Wait for move dialog to disappear
                page.wait_for_selector(MOVE_TO_SEARCH_INPUT_SELECTOR, state="detached", timeout=60_000)
                
                # Give Notion time to process the move
                time.sleep(3)

                # Step 3: Rename the duplicated page to remove any (1), (2) suffix
                print(f"Renaming duplicated page to original name: {original_child_name}")
                self.rename_page_via_api(duplicated_page_id, original_child_name)

                # Final validation: Check integrity of protected pages
                for protected_id, expected_title in self.protector.PROTECTED_PAGES.items():
                    try:
                        page_info = self.notion_client.pages.retrieve(page_id=protected_id)
                        props = page_info.get("properties", {})
                        title_prop = props.get("title", {}).get("title") or props.get("Name", {}).get("title")
                        current_title = "".join(t.get("plain_text", "") for t in title_prop).strip() if title_prop else "Unknown"

                        is_valid, warning = self.protector.verify_page_integrity(protected_id, current_title)
                        if not is_valid:
                            print(f"CRITICAL: {warning}")
                    except Exception as e:
                        print(f"WARNING: Could not verify protected page {protected_id}: {e}")

                # Save final auth state
                context.storage_state(path=str(self.state_file))
                
                print("Page successfully duplicated, moved, and renamed!")
                return duplicated_url
                
        except PlaywrightTimeoutError as e:
            print(f"Playwright timeout error: {e}")
            return None
        except Exception as e:
            print(f"Error during duplication: {e}")
            return None
    
    def duplicate_child_page(self, source_parent_url: str, child_name: str, target_parent_url: str) -> bool:
        """
        Main function to duplicate a child page from source parent to target parent.
        
        Args:
            source_parent_url: URL of the source parent page
            child_name: Name of the child page to duplicate
            target_parent_url: URL of the target parent page
            
        Returns:
            True if successful, False otherwise
        """
        try:
            # Extract page IDs from URLs
            source_parent_id = self.extract_page_id_from_url(source_parent_url)
            target_parent_id = self.extract_page_id_from_url(target_parent_url)
            
            print(f"Source parent ID: {source_parent_id}")
            print(f"Target parent ID: {target_parent_id}")
            
            # Find the child page
            print(f"Looking for child page '{child_name}'...")
            child_info = self.find_child_page_by_name(source_parent_id, child_name)
            
            if not child_info:
                print(f"Error: Child page '{child_name}' not found under source parent")
                return False
            
            child_page_id, child_page_url = child_info
            print(f"Found child page: {child_page_id}")
            
            # Get target parent title for the move operation
            target_parent_title = self.get_page_title_by_id(target_parent_id)
            print(f"Target parent title: {target_parent_title}")
            
            # Duplicate the child page and move it to target parent
            duplicated_url = self.duplicate_page_with_playwright(source_parent_url, child_page_url, target_parent_title, child_name)
            
            if duplicated_url:
                print(f"Success! Duplicated page URL: {duplicated_url}")
                return True
            else:
                print("Failed to duplicate the page")
                return False
                
        except Exception as e:
            print(f"Error in duplicate_child_page: {e}")
            return False

    def get_duplicated_page_id(self) -> Optional[str]:
        """Get the ID of the last duplicated page."""
        return self.duplicated_page_id

def save_page_id_to_file(page_id: str, file_path: str) -> bool:
    """
    Save the page ID to a specified file.
    
    Args:
        page_id: The page ID to save
        file_path: The file path where to save the ID
        
    Returns:
        True if successful, False otherwise
    """
    try:
        output_file = Path(file_path)
        # Create parent directories if they don't exist
        output_file.parent.mkdir(parents=True, exist_ok=True)
        
        # Write the page ID to the file
        output_file.write_text(page_id)
        print(f"Page ID saved to: {file_path}")
        return True
    except Exception as e:
        print(f"Error saving page ID to file: {e}")
        return False

def main():
    """Command line interface for the page duplicator."""
    parser = argparse.ArgumentParser(
        description="Duplicate a Notion child page from one parent to another",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    
    parser.add_argument(
        "--source-parent",
        required=True,
        help="URL of the source parent page",
    )
    
    parser.add_argument(
        "--child-name",
        required=True,
        help="Name of the child page to duplicate",
    )
    
    parser.add_argument(
        "--target-parent",
        required=True,
        help="URL of the target parent page",
    )
    
    parser.add_argument(
        "--notion-key",
        required=True,
        help="Notion API integration token",
    )
    
    parser.add_argument(
        "--output-file",
        help="File path to save the duplicated page ID (optional)",
    )
    
    parser.add_argument(
        "--browser",
        default="chromium",
        choices=["firefox", "chromium"],
        help="Browser to use for Playwright",
    )
    
    parser.add_argument(
        "--headless",
        action="store_true",
        default=True,
        help="Run browser in headless mode",
    )
    
    parser.add_argument(
        "--state-path",
        default="./configs/notion_state.json",
        help="The path to save the authenticated session state.",
    )
    
    args = parser.parse_args()
    
    try:
        duplicator = NotionPageDuplicator(
            notion_key=args.notion_key,
            browser=args.browser,
            headless=args.headless,
            state_path=args.state_path,
        )
        
        success = duplicator.duplicate_child_page(
            source_parent_url=args.source_parent,
            child_name=args.child_name,
            target_parent_url=args.target_parent,
        )
        
        if success:
            print("\n✅ Page duplication completed successfully!")
            
            # Save the duplicated page ID to file if output file is specified
            if args.output_file:
                duplicated_id = duplicator.get_duplicated_page_id()
                if duplicated_id:
                    if save_page_id_to_file(duplicated_id, args.output_file):
                        print(f"✅ Page ID '{duplicated_id}' saved to {args.output_file}")
                    else:
                        print(f"⚠️ Failed to save page ID to {args.output_file}")
                else:
                    print("⚠️ Could not retrieve duplicated page ID")
            
            exit(0)
        else:
            print("\n❌ Page duplication failed!")
            exit(1)
            
    except Exception as e:
        print(f"❌ Error: {e}")
        exit(1)

if __name__ == "__main__":
    main()